{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quantum Simulator The Quantum Simulator is an educational and experimental tool designed to simulate quantum key distribution (QKD) protocols with realistic noise and error models. Developed by Team Hiesenberg + Quantastic at IISER Bhopal, the simulator offers both a backend simulation engine and a user-friendly interface for interactive exploration. Project Overview This project aims to bridge the gap between theoretical QKD concepts and practical implementation by allowing users to: Simulate various QKD protocols under realistic conditions Introduce and visualize noise, loss, and imperfections Explore secure key exchange across network topologies Features Custom Simulation Engine Built from scratch, supporting multiple QKD protocols with adjustable error models and parameters. Interactive UI Allows users to: Select the number of nodes in the QKD network Choose network topology (e.g., linear, mesh) Pick cities on the map of India to form nodes Assign QKD protocols to edges (e.g., BB84, B92) Real-Time Visualization View key simulation metrics such as: Quantum Bit Error Rate (QBER) Key rate Sender's last sent bits Receiver's last received bits Use Cases The simulator can be used for: Demonstrating QKD to students and researchers Exploring protocol performance under realistic conditions Testing the effects of different topologies and parameters Running Locally Install Python dependencies (for the backend): pip install flask flask-cors simpy Start the backend server: python app.py Install frontend dependencies: npm install Run the frontend: npm run dev","title":"Home"},{"location":"#quantum-simulator","text":"The Quantum Simulator is an educational and experimental tool designed to simulate quantum key distribution (QKD) protocols with realistic noise and error models. Developed by Team Hiesenberg + Quantastic at IISER Bhopal, the simulator offers both a backend simulation engine and a user-friendly interface for interactive exploration.","title":"Quantum Simulator"},{"location":"#project-overview","text":"This project aims to bridge the gap between theoretical QKD concepts and practical implementation by allowing users to: Simulate various QKD protocols under realistic conditions Introduce and visualize noise, loss, and imperfections Explore secure key exchange across network topologies","title":"Project Overview"},{"location":"#features","text":"Custom Simulation Engine Built from scratch, supporting multiple QKD protocols with adjustable error models and parameters. Interactive UI Allows users to: Select the number of nodes in the QKD network Choose network topology (e.g., linear, mesh) Pick cities on the map of India to form nodes Assign QKD protocols to edges (e.g., BB84, B92) Real-Time Visualization View key simulation metrics such as: Quantum Bit Error Rate (QBER) Key rate Sender's last sent bits Receiver's last received bits","title":"Features"},{"location":"#use-cases","text":"The simulator can be used for: Demonstrating QKD to students and researchers Exploring protocol performance under realistic conditions Testing the effects of different topologies and parameters","title":"Use Cases"},{"location":"#running-locally","text":"Install Python dependencies (for the backend): pip install flask flask-cors simpy Start the backend server: python app.py Install frontend dependencies: npm install Run the frontend: npm run dev","title":"Running Locally"},{"location":"Hardware/","text":"Hardware Module This module contains implementations of core physical components used in QKD setups. Each file represents a modeled device with its behavior defined through classes and methods. 1. Hardware lasers.py (uses pulse.py ) The lasers.py module models a laser source capable of emitting light pulses. In the context of QKD, it simulates the emission of optical pulses used to encode and transmit quantum information. The generated pulses can carry polarization or phase-encoded quantum states, serving as carriers in the QKD protocol. Class: Laser(wavelength: float, amplitude: float) Functions: emit_pulse(duration: float, phase: float, quantum_state: None | QuantumState) Returns an instance of the Pulse class. pulse.py A pulse represents a discrete transmission of quantum information in the form of electromagnetic energy. In QKD, pulses carry encoded quantum states (e.g., polarization) and are the physical medium used to transmit bits securely. Class: Pulse(wavelength: float, duration: float, amplitude: float, phase: float, shape: callable, quantum_state: QuantumState, polarisation) Functions: photon_energy() Returns the energy of a single photon ( E = hc / \u03bb ). calculate_energy() Returns the energy of the entire wave. default_shape(t) Returns the default shape of the wave (Gaussian). sample_photon_arrivals() Returns a list of Pulse instances, each representing a photon. The number of photons is Poisson-distributed based on the mean photon number (Weak Coherent Pulses). Note: The polarization and quantum state can be defined independently. The simulator does not enforce consistency between the two. MZI.py (uses pulse.py , snspd.py ) The Mach-Zehnder Interferometer (MZI) is an optical device used to measure phase shifts in quantum signals. In QKD simulations, it allows for interference-based measurements that are crucial for certain protocols (e.g., phase-encoded QKD). By comparing the phase of incoming pulses, the MZI helps determine bit values based on interference outcomes. Class: MachZehnderInterferometer(snspd0: SNSPD, snspd1: SNSPD, visibility: float, phase_noise_std: float) Functions: measure(pulse_prev: Pulse, pulse_next: Pulse, current_time: simpy time) Returns: 0 if detector 0 is activated (phase difference = 0) 1 if detector 1 is activated (phase difference = \u03c0) Additional metadata in a dictionary snspd.py The Superconducting Nanowire Single-Photon Detector (SNSPD) is a highly sensitive photon detector used in QKD systems. It detects the arrival of individual photons with high efficiency and low noise, making it ideal for secure quantum communication where precise detection is critical. Class: SNSPD(efficiency: float, dark_count_rate: Hz, dead_time, timing_jitter, efficiency_spectrum) Functions: detect(pulse, current_time: float, detection_window) Returns a tuple: True/False (was a detection registered) Info dictionary: dark_count: bool detected: bool detection_time sps.py The Single Photon Source (SPS) module models the emission of individual photons used in quantum communication. It simulates realistic imperfections such as polarization errors and depolarization effects, which are essential for evaluating the robustness of QKD protocols in practical conditions. Class: SPS Functions: _apply_polarization_error(qstate: QuantumState) Applies a bit flip due to polarization error. _apply_depolarization(qstate) Depolarizes the quantum state. emit_pulse(trigger_time: float) Returns a pulse and an info dictionary. get_g2_0_empirical() Returns the second-order correlation function (empirical). HWP.py The Half-Wave Plate (HWP) is an optical device that rotates the polarization of light. In QKD simulations, it is used to implement polarization encoding by altering the state of incoming photons. The model includes imperfections such as angle errors and depolarization to simulate realistic scenarios. Class: HalfWavePlate(theta_deg, angle_error_std: radians, depol_prob: float) PBS.py The Polarizing Beam Splitter (PBS) is an optical component used to separate incoming light based on its polarization. In QKD simulations, it helps route photons according to their polarization state, enabling polarization-based encoding and measurement. The implementation includes realistic imperfections such as extinction ratio and angular jitter. Class: PolarizingBeamSplitter(extinction_ratio_db, angle_jitter_std) 2. Quantum State state.py The state.py module defines the quantum state representation used throughout the simulation. It includes tools for defining, manipulating, and measuring single-qubit quantum states represented by vectors or density matrices. Class: QuantumState(ket: np.ndarray, rho: np.ndarray) Functions: apply_gate(unitary_matrix) Applies a single-qubit unitary transformation. depolarize() Depolarizes the state completely. measure(projectors, shots) Simulates measurement and state collapse. Returns a dictionary of basis state occurrences. gates.py The gates.py module contains standard quantum gates (e.g., Pauli, Hadamard) represented as matrices. These gates can be applied to QuantumState objects. Users can also define custom gates and add them to this module. Contains predefined gates and their matrices. Users can define and add custom gates here. 3. Node and Channel node.py The node.py module defines the abstraction for network nodes in the QKD system. Each node acts as a sender or receiver of quantum or classical data and can be configured with hardware components and communication ports. Class: Node(node_id, env: simpy.Environment) Functions: assign_port(port_id, port_name) add_component(comp_name, comp_obj) connect_nodes(sender_port_id, receiver_port_id, receiver_node_id, channel_obj) send(sender_port_id, data) receive(data, receiver_port_id) The receive method is used to model simulation delay and is overridden in protocol-specific implementations. channel.py The channel.py module simulates the communication medium between nodes. It models both quantum and classical channels with parameters such as distance-based loss, transmission delay, and noise. Class: OpticalChannel(name, length_meters, attenuation_db_per_m, light_speed=2e8) Functions: compute_loss() compute_delay() Subclasses: QuantumChannel : Adds depolarizing noise. ClassicalChannel : Adds delay, no loss.","title":"Hardware"},{"location":"Hardware/#hardware-module","text":"This module contains implementations of core physical components used in QKD setups. Each file represents a modeled device with its behavior defined through classes and methods.","title":"Hardware Module"},{"location":"Hardware/#1-hardware","text":"","title":"1. Hardware"},{"location":"Hardware/#laserspy-uses-pulsepy","text":"The lasers.py module models a laser source capable of emitting light pulses. In the context of QKD, it simulates the emission of optical pulses used to encode and transmit quantum information. The generated pulses can carry polarization or phase-encoded quantum states, serving as carriers in the QKD protocol. Class: Laser(wavelength: float, amplitude: float) Functions: emit_pulse(duration: float, phase: float, quantum_state: None | QuantumState) Returns an instance of the Pulse class.","title":"lasers.py (uses pulse.py)"},{"location":"Hardware/#pulsepy","text":"A pulse represents a discrete transmission of quantum information in the form of electromagnetic energy. In QKD, pulses carry encoded quantum states (e.g., polarization) and are the physical medium used to transmit bits securely. Class: Pulse(wavelength: float, duration: float, amplitude: float, phase: float, shape: callable, quantum_state: QuantumState, polarisation) Functions: photon_energy() Returns the energy of a single photon ( E = hc / \u03bb ). calculate_energy() Returns the energy of the entire wave. default_shape(t) Returns the default shape of the wave (Gaussian). sample_photon_arrivals() Returns a list of Pulse instances, each representing a photon. The number of photons is Poisson-distributed based on the mean photon number (Weak Coherent Pulses). Note: The polarization and quantum state can be defined independently. The simulator does not enforce consistency between the two.","title":"pulse.py"},{"location":"Hardware/#mzipy-uses-pulsepy-snspdpy","text":"The Mach-Zehnder Interferometer (MZI) is an optical device used to measure phase shifts in quantum signals. In QKD simulations, it allows for interference-based measurements that are crucial for certain protocols (e.g., phase-encoded QKD). By comparing the phase of incoming pulses, the MZI helps determine bit values based on interference outcomes. Class: MachZehnderInterferometer(snspd0: SNSPD, snspd1: SNSPD, visibility: float, phase_noise_std: float) Functions: measure(pulse_prev: Pulse, pulse_next: Pulse, current_time: simpy time) Returns: 0 if detector 0 is activated (phase difference = 0) 1 if detector 1 is activated (phase difference = \u03c0) Additional metadata in a dictionary","title":"MZI.py (uses pulse.py, snspd.py)"},{"location":"Hardware/#snspdpy","text":"The Superconducting Nanowire Single-Photon Detector (SNSPD) is a highly sensitive photon detector used in QKD systems. It detects the arrival of individual photons with high efficiency and low noise, making it ideal for secure quantum communication where precise detection is critical. Class: SNSPD(efficiency: float, dark_count_rate: Hz, dead_time, timing_jitter, efficiency_spectrum) Functions: detect(pulse, current_time: float, detection_window) Returns a tuple: True/False (was a detection registered) Info dictionary: dark_count: bool detected: bool detection_time","title":"snspd.py"},{"location":"Hardware/#spspy","text":"The Single Photon Source (SPS) module models the emission of individual photons used in quantum communication. It simulates realistic imperfections such as polarization errors and depolarization effects, which are essential for evaluating the robustness of QKD protocols in practical conditions. Class: SPS Functions: _apply_polarization_error(qstate: QuantumState) Applies a bit flip due to polarization error. _apply_depolarization(qstate) Depolarizes the quantum state. emit_pulse(trigger_time: float) Returns a pulse and an info dictionary. get_g2_0_empirical() Returns the second-order correlation function (empirical).","title":"sps.py"},{"location":"Hardware/#hwppy","text":"The Half-Wave Plate (HWP) is an optical device that rotates the polarization of light. In QKD simulations, it is used to implement polarization encoding by altering the state of incoming photons. The model includes imperfections such as angle errors and depolarization to simulate realistic scenarios. Class: HalfWavePlate(theta_deg, angle_error_std: radians, depol_prob: float)","title":"HWP.py"},{"location":"Hardware/#pbspy","text":"The Polarizing Beam Splitter (PBS) is an optical component used to separate incoming light based on its polarization. In QKD simulations, it helps route photons according to their polarization state, enabling polarization-based encoding and measurement. The implementation includes realistic imperfections such as extinction ratio and angular jitter. Class: PolarizingBeamSplitter(extinction_ratio_db, angle_jitter_std)","title":"PBS.py"},{"location":"Hardware/#2-quantum-state","text":"","title":"2. Quantum State"},{"location":"Hardware/#statepy","text":"The state.py module defines the quantum state representation used throughout the simulation. It includes tools for defining, manipulating, and measuring single-qubit quantum states represented by vectors or density matrices. Class: QuantumState(ket: np.ndarray, rho: np.ndarray) Functions: apply_gate(unitary_matrix) Applies a single-qubit unitary transformation. depolarize() Depolarizes the state completely. measure(projectors, shots) Simulates measurement and state collapse. Returns a dictionary of basis state occurrences.","title":"state.py"},{"location":"Hardware/#gatespy","text":"The gates.py module contains standard quantum gates (e.g., Pauli, Hadamard) represented as matrices. These gates can be applied to QuantumState objects. Users can also define custom gates and add them to this module. Contains predefined gates and their matrices. Users can define and add custom gates here.","title":"gates.py"},{"location":"Hardware/#3-node-and-channel","text":"","title":"3. Node and Channel"},{"location":"Hardware/#nodepy","text":"The node.py module defines the abstraction for network nodes in the QKD system. Each node acts as a sender or receiver of quantum or classical data and can be configured with hardware components and communication ports. Class: Node(node_id, env: simpy.Environment) Functions: assign_port(port_id, port_name) add_component(comp_name, comp_obj) connect_nodes(sender_port_id, receiver_port_id, receiver_node_id, channel_obj) send(sender_port_id, data) receive(data, receiver_port_id) The receive method is used to model simulation delay and is overridden in protocol-specific implementations.","title":"node.py"},{"location":"Hardware/#channelpy","text":"The channel.py module simulates the communication medium between nodes. It models both quantum and classical channels with parameters such as distance-based loss, transmission delay, and noise. Class: OpticalChannel(name, length_meters, attenuation_db_per_m, light_speed=2e8) Functions: compute_loss() compute_delay() Subclasses: QuantumChannel : Adds depolarizing noise. ClassicalChannel : Adds delay, no loss.","title":"channel.py"},{"location":"Protocols/","text":"","title":"Protocol"},{"location":"Topology/","text":"Topology Module This module defines an abstract Topology class and specific subclasses for star, ring, and mesh network configurations. It is responsible for building and managing the structure of a quantum network in terms of nodes and optical channels. Classes Topology Represents a generic network topology for QKD nodes and their connecting channels. Constructor: Topology(node_specs: dict, channel_specs: dict) node_specs : A dictionary where keys are node IDs and values are dictionaries containing: type : Role of the node (e.g., \"Sender\", \"Receiver\") factory : A callable that returns a node object. channel_specs : A dictionary where keys are (node_a, node_b) tuples and values are callables that return an OpticalChannel object. Attributes: self.nodes : Dictionary mapping node IDs to constructed Node instances. self.channels : Dictionary mapping (node_a, node_b) tuples to OpticalChannel instances. Methods: buildTopology(env, num_pulses) Builds the topology by instantiating nodes and connecting them with channels. env : SimPy environment. num_pulses : Number of pulses the node will handle. get_node(node_id) Returns the node object corresponding to node_id . get_neighbors(node_id) Returns a list of node IDs that are directly connected to the specified node. StarTopology A specialization of Topology representing a star-shaped network. Constructor: StarTopology(center_node_id, leaf_node_ids, node_specs, channel_specs) center_node_id : ID of the central node. leaf_node_ids : List of IDs of peripheral nodes. Inherits and initializes from the Topology class. Attributes: self.center : Central node ID. self.leaves : List of peripheral node IDs. RingTopology A specialization of Topology representing a ring network. Constructor: RingTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the ring. Inherits from the Topology class. Attributes: self.ring_nodes : Node IDs in ring structure. MeshTopology A specialization of Topology representing a fully connected mesh network. Constructor: MeshTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the mesh. Inherits from the Topology class. Attributes: self.mesh_nodes : Node IDs in mesh structure.","title":"Topology"},{"location":"Topology/#topology-module","text":"This module defines an abstract Topology class and specific subclasses for star, ring, and mesh network configurations. It is responsible for building and managing the structure of a quantum network in terms of nodes and optical channels.","title":"Topology Module"},{"location":"Topology/#classes","text":"","title":"Classes"},{"location":"Topology/#topology","text":"Represents a generic network topology for QKD nodes and their connecting channels. Constructor: Topology(node_specs: dict, channel_specs: dict) node_specs : A dictionary where keys are node IDs and values are dictionaries containing: type : Role of the node (e.g., \"Sender\", \"Receiver\") factory : A callable that returns a node object. channel_specs : A dictionary where keys are (node_a, node_b) tuples and values are callables that return an OpticalChannel object. Attributes: self.nodes : Dictionary mapping node IDs to constructed Node instances. self.channels : Dictionary mapping (node_a, node_b) tuples to OpticalChannel instances. Methods: buildTopology(env, num_pulses) Builds the topology by instantiating nodes and connecting them with channels. env : SimPy environment. num_pulses : Number of pulses the node will handle. get_node(node_id) Returns the node object corresponding to node_id . get_neighbors(node_id) Returns a list of node IDs that are directly connected to the specified node.","title":"Topology"},{"location":"Topology/#startopology","text":"A specialization of Topology representing a star-shaped network. Constructor: StarTopology(center_node_id, leaf_node_ids, node_specs, channel_specs) center_node_id : ID of the central node. leaf_node_ids : List of IDs of peripheral nodes. Inherits and initializes from the Topology class. Attributes: self.center : Central node ID. self.leaves : List of peripheral node IDs.","title":"StarTopology"},{"location":"Topology/#ringtopology","text":"A specialization of Topology representing a ring network. Constructor: RingTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the ring. Inherits from the Topology class. Attributes: self.ring_nodes : Node IDs in ring structure.","title":"RingTopology"},{"location":"Topology/#meshtopology","text":"A specialization of Topology representing a fully connected mesh network. Constructor: MeshTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the mesh. Inherits from the Topology class. Attributes: self.mesh_nodes : Node IDs in mesh structure.","title":"MeshTopology"},{"location":"Usage/","text":"Usage Guide This simulator allows users to explore quantum key distribution (QKD) protocols in a configurable network environment. The system is designed to be interactive and intuitive, with visual feedback at each step. Node Selection Users can select up to 6 nodes to include in the QKD network. Each node corresponds to a city in India. Cities are displayed on an interactive map of India. Clicking on a city adds it to the network. The simulator calculates distances between selected cities to model realistic fiber-optic transmission losses. Topology Selection After selecting the nodes, users can choose a network topology to define how the nodes are connected. Available topologies include: Star A central node connected to all others. Mesh All nodes are directly connected to each other. Ring Each node is connected to two others, forming a closed loop. Each edge (i.e., connection between two nodes) can be assigned a QKD protocol to simulate. Supported protocols include: BB84 COW DPS The selected protocol will determine how key bits are generated and transmitted between nodes. Simulation and Output Once nodes, topology, and protocols are selected, the simulator runs a complete QKD session over the network. Output metrics are displayed in real time on the page, including: QBER (Quantum Bit Error Rate) Key rate Sender's last sent bits Receiver's last received bits","title":"Usage Guide"},{"location":"Usage/#usage-guide","text":"This simulator allows users to explore quantum key distribution (QKD) protocols in a configurable network environment. The system is designed to be interactive and intuitive, with visual feedback at each step.","title":"Usage Guide"},{"location":"Usage/#node-selection","text":"Users can select up to 6 nodes to include in the QKD network. Each node corresponds to a city in India. Cities are displayed on an interactive map of India. Clicking on a city adds it to the network. The simulator calculates distances between selected cities to model realistic fiber-optic transmission losses.","title":"Node Selection"},{"location":"Usage/#topology-selection","text":"After selecting the nodes, users can choose a network topology to define how the nodes are connected. Available topologies include: Star A central node connected to all others. Mesh All nodes are directly connected to each other. Ring Each node is connected to two others, forming a closed loop. Each edge (i.e., connection between two nodes) can be assigned a QKD protocol to simulate. Supported protocols include: BB84 COW DPS The selected protocol will determine how key bits are generated and transmitted between nodes.","title":"Topology Selection"},{"location":"Usage/#simulation-and-output","text":"Once nodes, topology, and protocols are selected, the simulator runs a complete QKD session over the network. Output metrics are displayed in real time on the page, including: QBER (Quantum Bit Error Rate) Key rate Sender's last sent bits Receiver's last received bits","title":"Simulation and Output"},{"location":"Utility/","text":"Utils Module This module provides utility functions and components that support key QKD operations such as entanglement generation, key rate analysis, and unit testing. 1. entanglement_manage.py Provides tools for generating Bell pairs and distributing them between two quantum nodes. Class: EntanglementManager Handles the creation and distribution of entangled quantum states between two nodes. Methods: __init__() Initializes an empty dictionary of entangled pairs. create_bell_pair(node_a: Node, node_b: Node, bell_type='00') Creates a Bell state (default \u03a6\u207a) between node_a and node_b . Applies Hadamard and CNOT to prepare the state. Returns a pair ID and the shared quantum state. Use case: Used in protocols like E91 to simulate entanglement-based QKD. 2. key_rate.py Implements formulas for computing the theoretical key generation rate. Function: binary_entropy(q) Returns the Shannon binary entropy of probability q . If q is 0 or 1, returns 0. Function: compute_key_rate(qber, sifted_rate=0.5) Computes the asymptotic key rate for a given QBER (Quantum Bit Error Rate). Applies the formula: key_rate = sifted_rate \u00d7 max(0, 1 - 2 \u00d7 H(qber)) Returns a rounded value to 6 decimal places. Use case: Estimating secret key yield under noisy channels. 3. test.py Test script to validate entanglement correlation between two nodes. Purpose: Verifies that Bell pairs created by EntanglementManager result in perfectly correlated measurement outcomes. Performs 1000 trials and prints the count of matching outcomes. Key Elements: Uses a DummyEnv class to mock SimPy environment. Creates two nodes ( Alice and Bob ). Creates Bell pairs and measures in the Z-basis. Uses Python\u2019s Counter to analyze frequency of correlated outcomes. Use case: Demonstrates entanglement fidelity and correlation statistics for Bell state \u03a6\u207a in the simulation.","title":"Utils"},{"location":"Utility/#utils-module","text":"This module provides utility functions and components that support key QKD operations such as entanglement generation, key rate analysis, and unit testing.","title":"Utils Module"},{"location":"Utility/#1-entanglement_managepy","text":"Provides tools for generating Bell pairs and distributing them between two quantum nodes.","title":"1. entanglement_manage.py"},{"location":"Utility/#class-entanglementmanager","text":"Handles the creation and distribution of entangled quantum states between two nodes. Methods: __init__() Initializes an empty dictionary of entangled pairs. create_bell_pair(node_a: Node, node_b: Node, bell_type='00') Creates a Bell state (default \u03a6\u207a) between node_a and node_b . Applies Hadamard and CNOT to prepare the state. Returns a pair ID and the shared quantum state. Use case: Used in protocols like E91 to simulate entanglement-based QKD.","title":"Class: EntanglementManager"},{"location":"Utility/#2-key_ratepy","text":"Implements formulas for computing the theoretical key generation rate.","title":"2. key_rate.py"},{"location":"Utility/#function-binary_entropyq","text":"Returns the Shannon binary entropy of probability q . If q is 0 or 1, returns 0.","title":"Function: binary_entropy(q)"},{"location":"Utility/#function-compute_key_rateqber-sifted_rate05","text":"Computes the asymptotic key rate for a given QBER (Quantum Bit Error Rate). Applies the formula: key_rate = sifted_rate \u00d7 max(0, 1 - 2 \u00d7 H(qber)) Returns a rounded value to 6 decimal places. Use case: Estimating secret key yield under noisy channels.","title":"Function: compute_key_rate(qber, sifted_rate=0.5)"},{"location":"Utility/#3-testpy","text":"Test script to validate entanglement correlation between two nodes.","title":"3. test.py"},{"location":"Utility/#purpose","text":"Verifies that Bell pairs created by EntanglementManager result in perfectly correlated measurement outcomes. Performs 1000 trials and prints the count of matching outcomes.","title":"Purpose:"},{"location":"Utility/#key-elements","text":"Uses a DummyEnv class to mock SimPy environment. Creates two nodes ( Alice and Bob ). Creates Bell pairs and measures in the Z-basis. Uses Python\u2019s Counter to analyze frequency of correlated outcomes. Use case: Demonstrates entanglement fidelity and correlation statistics for Bell state \u03a6\u207a in the simulation.","title":"Key Elements:"}]}