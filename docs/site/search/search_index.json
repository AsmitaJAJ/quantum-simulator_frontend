{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quantum Simulator The Quantum Simulator is an educational and experimental tool designed to simulate quantum key distribution (QKD) protocols with realistic noise and error models. Developed by Team Hiesenberg + Quantastic at IISER Bhopal, the simulator offers both a backend simulation engine and a user-friendly interface for interactive exploration. Project Overview This project aims to bridge the gap between theoretical QKD concepts and practical implementation by allowing users to: Simulate various QKD protocols under realistic conditions Introduce and visualize noise, loss, and imperfections Explore secure key exchange across network topologies Features Custom Simulation Engine Built from scratch, supporting multiple QKD protocols with adjustable error models and parameters. Interactive UI Allows users to: Select the number of nodes in the QKD network Choose network topology (e.g., linear, mesh) Pick cities on the map of India to form nodes Assign QKD protocols to edges (e.g., BB84, B92) Real-Time Visualization View key simulation metrics such as: Quantum Bit Error Rate (QBER) Key rate Sender's last sent bits Receiver's last received bits Use Cases The simulator can be used for: Demonstrating QKD to students and researchers Exploring protocol performance under realistic conditions Testing the effects of different topologies and parameters Running Locally Install Python dependencies (for the backend): pip install flask flask-cors simpy Start the backend server: python app.py Install frontend dependencies: npm install Run the frontend: npm run dev","title":"Home"},{"location":"#quantum-simulator","text":"The Quantum Simulator is an educational and experimental tool designed to simulate quantum key distribution (QKD) protocols with realistic noise and error models. Developed by Team Hiesenberg + Quantastic at IISER Bhopal, the simulator offers both a backend simulation engine and a user-friendly interface for interactive exploration.","title":"Quantum Simulator"},{"location":"#project-overview","text":"This project aims to bridge the gap between theoretical QKD concepts and practical implementation by allowing users to: Simulate various QKD protocols under realistic conditions Introduce and visualize noise, loss, and imperfections Explore secure key exchange across network topologies","title":"Project Overview"},{"location":"#features","text":"Custom Simulation Engine Built from scratch, supporting multiple QKD protocols with adjustable error models and parameters. Interactive UI Allows users to: Select the number of nodes in the QKD network Choose network topology (e.g., linear, mesh) Pick cities on the map of India to form nodes Assign QKD protocols to edges (e.g., BB84, B92) Real-Time Visualization View key simulation metrics such as: Quantum Bit Error Rate (QBER) Key rate Sender's last sent bits Receiver's last received bits","title":"Features"},{"location":"#use-cases","text":"The simulator can be used for: Demonstrating QKD to students and researchers Exploring protocol performance under realistic conditions Testing the effects of different topologies and parameters","title":"Use Cases"},{"location":"#running-locally","text":"Install Python dependencies (for the backend): pip install flask flask-cors simpy Start the backend server: python app.py Install frontend dependencies: npm install Run the frontend: npm run dev","title":"Running Locally"},{"location":"Hardware/","text":"Hardware Module This module contains implementations of core physical components used in QKD setups. Each file represents a modeled device with its behavior defined through classes and methods. 1. Hardware lasers.py (uses pulse.py ) The lasers.py module models a laser source capable of emitting light pulses. In the context of QKD, it simulates the emission of optical pulses used to encode and transmit quantum information. The generated pulses can carry polarization or phase-encoded quantum states, serving as carriers in the QKD protocol. Class: Laser(wavelength: float, amplitude: float) Functions: emit_pulse(duration: float, phase: float, quantum_state: None | QuantumState) Returns an instance of the Pulse class. pulse.py A pulse represents a discrete transmission of quantum information in the form of electromagnetic energy. In QKD, pulses carry encoded quantum states (e.g., polarization) and are the physical medium used to transmit bits securely. Class: Pulse(wavelength: float, duration: float, amplitude: float, phase: float, shape: callable, quantum_state: QuantumState, polarisation) Functions: photon_energy() Returns the energy of a single photon ( E = hc / \u03bb ). calculate_energy() Returns the energy of the entire wave. default_shape(t) Returns the default shape of the wave (Gaussian). sample_photon_arrivals() Returns a list of Pulse instances, each representing a photon. The number of photons is Poisson-distributed based on the mean photon number (Weak Coherent Pulses). Note: The polarization and quantum state can be defined independently. The simulator does not enforce consistency between the two. MZI.py (uses pulse.py , snspd.py ) The Mach-Zehnder Interferometer (MZI) is an optical device used to measure phase shifts in quantum signals. In QKD simulations, it allows for interference-based measurements that are crucial for certain protocols (e.g., phase-encoded QKD). By comparing the phase of incoming pulses, the MZI helps determine bit values based on interference outcomes. Class: MachZehnderInterferometer(snspd0: SNSPD, snspd1: SNSPD, visibility: float, phase_noise_std: float) Functions: measure(pulse_prev: Pulse, pulse_next: Pulse, current_time: simpy time) Returns: 0 if detector 0 is activated (phase difference = 0) 1 if detector 1 is activated (phase difference = \u03c0) Additional metadata in a dictionary snspd.py The Superconducting Nanowire Single-Photon Detector (SNSPD) is a highly sensitive photon detector used in QKD systems. It detects the arrival of individual photons with high efficiency and low noise, making it ideal for secure quantum communication where precise detection is critical. Class: SNSPD(efficiency: float, dark_count_rate: Hz, dead_time, timing_jitter, efficiency_spectrum) Functions: detect(pulse, current_time: float, detection_window) Returns a tuple: True/False (was a detection registered) Info dictionary: dark_count: bool detected: bool detection_time sps.py The Single Photon Source (SPS) module models the emission of individual photons used in quantum communication. It simulates realistic imperfections such as polarization errors and depolarization effects, which are essential for evaluating the robustness of QKD protocols in practical conditions. Class: SPS Functions: _apply_polarization_error(qstate: QuantumState) Applies a bit flip due to polarization error. _apply_depolarization(qstate) Depolarizes the quantum state. emit_pulse(trigger_time: float) Returns a pulse and an info dictionary. get_g2_0_empirical() Returns the second-order correlation function (empirical). HWP.py The Half-Wave Plate (HWP) is an optical device that rotates the polarization of light. In QKD simulations, it is used to implement polarization encoding by altering the state of incoming photons. The model includes imperfections such as angle errors and depolarization to simulate realistic scenarios. Class: HalfWavePlate(theta_deg, angle_error_std: radians, depol_prob: float) PBS.py The Polarizing Beam Splitter (PBS) is an optical component used to separate incoming light based on its polarization. In QKD simulations, it helps route photons according to their polarization state, enabling polarization-based encoding and measurement. The implementation includes realistic imperfections such as extinction ratio and angular jitter. Class: PolarizingBeamSplitter(extinction_ratio_db, angle_jitter_std) 2. Quantum State state.py The state.py module defines the quantum state representation used throughout the simulation. It includes tools for defining, manipulating, and measuring single-qubit quantum states represented by vectors or density matrices. Class: QuantumState(ket: np.ndarray, rho: np.ndarray) Functions: apply_gate(unitary_matrix) Applies a single-qubit unitary transformation. depolarize() Depolarizes the state completely. measure(projectors, shots) Simulates measurement and state collapse. Returns a dictionary of basis state occurrences. gates.py The gates.py module contains standard quantum gates (e.g., Pauli, Hadamard) represented as matrices. These gates can be applied to QuantumState objects. Users can also define custom gates and add them to this module. Contains predefined gates and their matrices. Users can define and add custom gates here. 3. Node and Channel node.py The node.py module defines the abstraction for network nodes in the QKD system. Each node acts as a sender or receiver of quantum or classical data and can be configured with hardware components and communication ports. Class: Node(node_id, env: simpy.Environment) Functions: assign_port(port_id, port_name) add_component(comp_name, comp_obj) connect_nodes(sender_port_id, receiver_port_id, receiver_node_id, channel_obj) send(sender_port_id, data) receive(data, receiver_port_id) The receive method is used to model simulation delay and is overridden in protocol-specific implementations. channel.py The channel.py module simulates the communication medium between nodes. It models both quantum and classical channels with parameters such as distance-based loss, transmission delay, and noise. Class: OpticalChannel(name, length_meters, attenuation_db_per_m, light_speed=2e8) Functions: compute_loss() compute_delay() Subclasses: QuantumChannel : Adds depolarizing noise. ClassicalChannel : Adds delay, no loss.","title":"Hardware"},{"location":"Hardware/#hardware-module","text":"This module contains implementations of core physical components used in QKD setups. Each file represents a modeled device with its behavior defined through classes and methods.","title":"Hardware Module"},{"location":"Hardware/#1-hardware","text":"","title":"1. Hardware"},{"location":"Hardware/#laserspy-uses-pulsepy","text":"The lasers.py module models a laser source capable of emitting light pulses. In the context of QKD, it simulates the emission of optical pulses used to encode and transmit quantum information. The generated pulses can carry polarization or phase-encoded quantum states, serving as carriers in the QKD protocol. Class: Laser(wavelength: float, amplitude: float) Functions: emit_pulse(duration: float, phase: float, quantum_state: None | QuantumState) Returns an instance of the Pulse class.","title":"lasers.py (uses pulse.py)"},{"location":"Hardware/#pulsepy","text":"A pulse represents a discrete transmission of quantum information in the form of electromagnetic energy. In QKD, pulses carry encoded quantum states (e.g., polarization) and are the physical medium used to transmit bits securely. Class: Pulse(wavelength: float, duration: float, amplitude: float, phase: float, shape: callable, quantum_state: QuantumState, polarisation) Functions: photon_energy() Returns the energy of a single photon ( E = hc / \u03bb ). calculate_energy() Returns the energy of the entire wave. default_shape(t) Returns the default shape of the wave (Gaussian). sample_photon_arrivals() Returns a list of Pulse instances, each representing a photon. The number of photons is Poisson-distributed based on the mean photon number (Weak Coherent Pulses). Note: The polarization and quantum state can be defined independently. The simulator does not enforce consistency between the two.","title":"pulse.py"},{"location":"Hardware/#mzipy-uses-pulsepy-snspdpy","text":"The Mach-Zehnder Interferometer (MZI) is an optical device used to measure phase shifts in quantum signals. In QKD simulations, it allows for interference-based measurements that are crucial for certain protocols (e.g., phase-encoded QKD). By comparing the phase of incoming pulses, the MZI helps determine bit values based on interference outcomes. Class: MachZehnderInterferometer(snspd0: SNSPD, snspd1: SNSPD, visibility: float, phase_noise_std: float) Functions: measure(pulse_prev: Pulse, pulse_next: Pulse, current_time: simpy time) Returns: 0 if detector 0 is activated (phase difference = 0) 1 if detector 1 is activated (phase difference = \u03c0) Additional metadata in a dictionary","title":"MZI.py (uses pulse.py, snspd.py)"},{"location":"Hardware/#snspdpy","text":"The Superconducting Nanowire Single-Photon Detector (SNSPD) is a highly sensitive photon detector used in QKD systems. It detects the arrival of individual photons with high efficiency and low noise, making it ideal for secure quantum communication where precise detection is critical. Class: SNSPD(efficiency: float, dark_count_rate: Hz, dead_time, timing_jitter, efficiency_spectrum) Functions: detect(pulse, current_time: float, detection_window) Returns a tuple: True/False (was a detection registered) Info dictionary: dark_count: bool detected: bool detection_time","title":"snspd.py"},{"location":"Hardware/#spspy","text":"The Single Photon Source (SPS) module models the emission of individual photons used in quantum communication. It simulates realistic imperfections such as polarization errors and depolarization effects, which are essential for evaluating the robustness of QKD protocols in practical conditions. Class: SPS Functions: _apply_polarization_error(qstate: QuantumState) Applies a bit flip due to polarization error. _apply_depolarization(qstate) Depolarizes the quantum state. emit_pulse(trigger_time: float) Returns a pulse and an info dictionary. get_g2_0_empirical() Returns the second-order correlation function (empirical).","title":"sps.py"},{"location":"Hardware/#hwppy","text":"The Half-Wave Plate (HWP) is an optical device that rotates the polarization of light. In QKD simulations, it is used to implement polarization encoding by altering the state of incoming photons. The model includes imperfections such as angle errors and depolarization to simulate realistic scenarios. Class: HalfWavePlate(theta_deg, angle_error_std: radians, depol_prob: float)","title":"HWP.py"},{"location":"Hardware/#pbspy","text":"The Polarizing Beam Splitter (PBS) is an optical component used to separate incoming light based on its polarization. In QKD simulations, it helps route photons according to their polarization state, enabling polarization-based encoding and measurement. The implementation includes realistic imperfections such as extinction ratio and angular jitter. Class: PolarizingBeamSplitter(extinction_ratio_db, angle_jitter_std)","title":"PBS.py"},{"location":"Hardware/#2-quantum-state","text":"","title":"2. Quantum State"},{"location":"Hardware/#statepy","text":"The state.py module defines the quantum state representation used throughout the simulation. It includes tools for defining, manipulating, and measuring single-qubit quantum states represented by vectors or density matrices. Class: QuantumState(ket: np.ndarray, rho: np.ndarray) Functions: apply_gate(unitary_matrix) Applies a single-qubit unitary transformation. depolarize() Depolarizes the state completely. measure(projectors, shots) Simulates measurement and state collapse. Returns a dictionary of basis state occurrences.","title":"state.py"},{"location":"Hardware/#gatespy","text":"The gates.py module contains standard quantum gates (e.g., Pauli, Hadamard) represented as matrices. These gates can be applied to QuantumState objects. Users can also define custom gates and add them to this module. Contains predefined gates and their matrices. Users can define and add custom gates here.","title":"gates.py"},{"location":"Hardware/#3-node-and-channel","text":"","title":"3. Node and Channel"},{"location":"Hardware/#nodepy","text":"The node.py module defines the abstraction for network nodes in the QKD system. Each node acts as a sender or receiver of quantum or classical data and can be configured with hardware components and communication ports. Class: Node(node_id, env: simpy.Environment) Functions: assign_port(port_id, port_name) add_component(comp_name, comp_obj) connect_nodes(sender_port_id, receiver_port_id, receiver_node_id, channel_obj) send(sender_port_id, data) receive(data, receiver_port_id) The receive method is used to model simulation delay and is overridden in protocol-specific implementations.","title":"node.py"},{"location":"Hardware/#channelpy","text":"The channel.py module simulates the communication medium between nodes. It models both quantum and classical channels with parameters such as distance-based loss, transmission delay, and noise. Class: OpticalChannel(name, length_meters, attenuation_db_per_m, light_speed=2e8) Functions: compute_loss() compute_delay() Subclasses: QuantumChannel : Adds depolarizing noise. ClassicalChannel : Adds delay, no loss.","title":"channel.py"},{"location":"Protocols/","text":"All simulated protocols BB84 Protocol Overview The BB84 protocol is a prepare-and-measure quantum key distribution (QKD) scheme based on encoding information into the polarization states of single photons. This simulation models BB84 using realistic quantum hardware components including: - Half-wave plates (HWPs) - Polarizing beam splitters (PBS) - Superconducting nanowire single-photon detectors (SNSPDs) - A quantum channel with configurable noise and attenuation Protocol Summary Preparation (Alice) Randomly chooses a bit (0 or 1) and an encoding basis (X or Z) Applies a half-wave plate to encode the polarization accordingly Sends a weak coherent pulse through a noisy quantum channel Measurement (Bob) Randomly selects a measurement basis (X or Z) Applies a half-wave plate and splits the polarization using a PBS Detects the photon via an SNSPD to determine the bit value Post-Processing Alice and Bob publicly compare bases Keep only the bits where both used the same basis (sifted key) Compute Quantum Bit Error Rate (QBER) Apply error correction and privacy amplification (asymptotic key rate) Simulation Parameters Parameter Description Default Value POL_ERR_STD Polarization noise in channel (deg) 1.0 BOB_HWP_ERR_STD HWP angle error at Bob (deg) 0.0 PBS_ANGLE_JITTER_STD Misalignment noise in PBS 0.0 PBS_EXTINCTION_DB Extinction ratio of PBS (dB) 60.0 DARK_COUNT_RATE SNSPD dark count rate (Hz) 10 SNSPD_EFFICIENCY SNSPD efficiency 0.9 SNSPD_JITTER SNSPD timing jitter (s) 40e-12 pulse.mean_photon_number Photon number per pulse 10 pulse.duration Pulse duration 70e-12 pulse.wavelength Pulse wavelength 1550e-9 num_pulses Total number of pulses sent 1,000,000 Class: Alice class Alice(Node): def __init__(self, node_id, env, num_pulses): Class: Bob class Bob(Node): def __init__(self, node_id, env): DPS Protocol Overview The DPS (Differential Phase Shift) protocol is a prepare-and-measure quantum key distribution (QKD) scheme that encodes bits using the phase difference between consecutive weak coherent pulses. It offers practical implementation advantages by relying on a simple setup involving: - Lasers emitting weak pulses - Mach-Zehnder interferometers (MZIs) - Superconducting nanowire detectors (SNSPDs) Protocol Summary Preparation (Alice) Uses a laser to emit a train of weak coherent pulses. Randomly applies phase shifts: 0 or \u03c0 to each pulse. Sends pulses one-by-one through a quantum channel. Measurement (Bob) Receives consecutive pulses and interferes them using a Mach-Zehnder interferometer. Based on the interference result (constructive or destructive), he infers whether the phase difference is 0 (bit = 0) or \u03c0 (bit = 1). The phase difference is what carries the key bit. Security Mechanism Since the key is encoded in the phase difference , any eavesdropping attempt (e.g., measuring a single pulse) destroys the coherence and introduces errors. QBER increases significantly (above 10-15%) if Eve tries to intercept. Simulation Parameters Parameter Description Default Value pulse.phase Phase shift applied to each pulse (0 or \u03c0) Random pulse.mean_photon_number Average photons per pulse 0.2 pulse.duration Pulse duration 70e-12 pulse.wavelength Pulse wavelength 1550e-9 num_pulses Total number of pulses sent 1,000,000 MZI.visibility Interferometer visibility 0.98 phase_noise_std Phase noise in interferometer 0.2 SNSPD efficiency Photon detection efficiency 0.9 dark count rate Background dark count rate 10 Hz Class: Alice class Alice(Node): def __init__(self, node_id, env, num_pulses): ... Class: Bob class Bob(Node): def __init__(self, node_id, env, mzi): ... Coherent-One-Way (COW) QKD Protocol Overview The COW protocol is a prepare-and-measure quantum key distribution (QKD) scheme using time-bin encoding and weak coherent pulses . It ensures security through decoy states and interference monitoring . Protocol Summary Preparation (Alice) Sends pulses in time-bin pairs. Bit 0 : Pulse in the first bin, vacuum in the second. Bit 1 : Vacuum in the first bin, pulse in the second. Decoy state : Pulses in both bins (used for eavesdropper detection). Transmission Pulses travel through a lossy, noisy quantum channel. Measurement (Bob) 90% of pulses are measured directly to form the key (data line). 10% are routed to an interferometer (monitor line) to detect interference. Post-Processing Sifted key is extracted from correctly timed detections. Decoy statistics and interferometer clicks ( DM2 ) are used to verify security. If too many DM2 detections occur, the protocol is aborted. Simulation Parameters Parameter Description Default num_pulses Number of time-bin pairs sent 1000 decoy_prob Probability of sending a decoy state 0.1 pulse.duration Duration of each pulse (s) 70e-12 pulse.mean_photon_number Average photon number per pulse 0.5 monitor_ratio Fraction of pulses sent to monitor line 0.1 visibility Interferometer visibility 0.98 phase_noise_std Standard deviation of phase noise 0.02 SNSPD efficiency Detector efficiency 0.9 SNSPD dark count rate Detector dark count rate (Hz) 10 Classes class Alice(Node) def __init__(self, node_id, env, num_pulses, decoy_prob): class Bob(Node) def __init__(self, node_id, env, snspd, monitor_ratio=0.1, threshold=5): E91 Quantum Key Distribution Protocol Overview The E91 protocol is an entanglement-based quantum key distribution (QKD) scheme. Instead of sending quantum states directly, Alice and Bob share entangled photon pairs and perform local measurements on them. The correlation of their results provides both a shared key and a built-in security check via Bell\u2019s inequality . This simulation uses: - Entangled photon pairs (|\u03a8\u207b\u27e9 state) - Configurable depolarization, misalignment, and detector flip errors - Local projective measurements in the x\u2013z plane - A trusted entanglement manager to distribute entangled pairs Protocol Summary Entanglement Creation A Bell pair in the state |\u03a8\u207b\u27e9 is distributed between Alice and Bob. State depolarization (Werner noise) is simulated via a tunable parameter p_depol . Measurement Alice randomly selects from measurement angles: 0, \u03c0/4, \u03c0/2 Bob randomly selects from: \u03c0/4, \u03c0/2, 3\u03c0/4 Both apply a small Gaussian misalignment to simulate real-world errors. Local projective measurements are performed using a custom function measure_local . Results are stored as \u00b11, and detector flip errors are injected with probability p_flip . Key Generation Only measurement rounds where Alice and Bob used the same nominal basis are retained. Alice and Bob convert \u00b11 \u2192 0/1. Bob flips his bit (due to anticorrelation of |\u03a8\u207b\u27e9) to match Alice. The resulting bit sequences form the sifted key . Security Check Measurement rounds with mismatched bases are used to compute the Bell parameter (S) . A violation of Bell\u2019s inequality (|S| > 2) confirms entanglement and quantum security. Simulation Parameters Parameter Description Default Value num_pulses Number of entangled pairs generated 10,000 p_depol Depolarization probability (white noise) 0.03 misalign_deg Angle misalignment std. dev (in degrees) 1.5 p_flip Probability of bit-flip due to detector error 0.01 clock_rate Entangled pair generation rate 10 MHz Class: Alice class Alice(Node): def __init__(self, node_id, env, num_pulses, p_depol, misalign_deg, p_flip) def run(self, manager, bob): # 1. Creates noisy entangled state # 2. Measures her half using basis angle \u03c6a # 3. Records outcome, applies noise and flip Class: Bob class Bob(Node): def __init__(self, node_id, env): self.phi_list = [] self.s_list = []","title":"Protocol"},{"location":"Protocols/#all-simulated-protocols","text":"","title":"All simulated protocols"},{"location":"Protocols/#bb84-protocol","text":"","title":"BB84 Protocol"},{"location":"Protocols/#overview","text":"The BB84 protocol is a prepare-and-measure quantum key distribution (QKD) scheme based on encoding information into the polarization states of single photons. This simulation models BB84 using realistic quantum hardware components including: - Half-wave plates (HWPs) - Polarizing beam splitters (PBS) - Superconducting nanowire single-photon detectors (SNSPDs) - A quantum channel with configurable noise and attenuation","title":"Overview"},{"location":"Protocols/#protocol-summary","text":"Preparation (Alice) Randomly chooses a bit (0 or 1) and an encoding basis (X or Z) Applies a half-wave plate to encode the polarization accordingly Sends a weak coherent pulse through a noisy quantum channel Measurement (Bob) Randomly selects a measurement basis (X or Z) Applies a half-wave plate and splits the polarization using a PBS Detects the photon via an SNSPD to determine the bit value Post-Processing Alice and Bob publicly compare bases Keep only the bits where both used the same basis (sifted key) Compute Quantum Bit Error Rate (QBER) Apply error correction and privacy amplification (asymptotic key rate)","title":"Protocol Summary"},{"location":"Protocols/#simulation-parameters","text":"Parameter Description Default Value POL_ERR_STD Polarization noise in channel (deg) 1.0 BOB_HWP_ERR_STD HWP angle error at Bob (deg) 0.0 PBS_ANGLE_JITTER_STD Misalignment noise in PBS 0.0 PBS_EXTINCTION_DB Extinction ratio of PBS (dB) 60.0 DARK_COUNT_RATE SNSPD dark count rate (Hz) 10 SNSPD_EFFICIENCY SNSPD efficiency 0.9 SNSPD_JITTER SNSPD timing jitter (s) 40e-12 pulse.mean_photon_number Photon number per pulse 10 pulse.duration Pulse duration 70e-12 pulse.wavelength Pulse wavelength 1550e-9 num_pulses Total number of pulses sent 1,000,000","title":"Simulation Parameters"},{"location":"Protocols/#class-alice","text":"class Alice(Node): def __init__(self, node_id, env, num_pulses):","title":"Class: Alice"},{"location":"Protocols/#class-bob","text":"class Bob(Node): def __init__(self, node_id, env):","title":"Class: Bob"},{"location":"Protocols/#dps-protocol","text":"","title":"DPS Protocol"},{"location":"Protocols/#overview_1","text":"The DPS (Differential Phase Shift) protocol is a prepare-and-measure quantum key distribution (QKD) scheme that encodes bits using the phase difference between consecutive weak coherent pulses. It offers practical implementation advantages by relying on a simple setup involving: - Lasers emitting weak pulses - Mach-Zehnder interferometers (MZIs) - Superconducting nanowire detectors (SNSPDs)","title":"Overview"},{"location":"Protocols/#protocol-summary_1","text":"Preparation (Alice) Uses a laser to emit a train of weak coherent pulses. Randomly applies phase shifts: 0 or \u03c0 to each pulse. Sends pulses one-by-one through a quantum channel. Measurement (Bob) Receives consecutive pulses and interferes them using a Mach-Zehnder interferometer. Based on the interference result (constructive or destructive), he infers whether the phase difference is 0 (bit = 0) or \u03c0 (bit = 1). The phase difference is what carries the key bit. Security Mechanism Since the key is encoded in the phase difference , any eavesdropping attempt (e.g., measuring a single pulse) destroys the coherence and introduces errors. QBER increases significantly (above 10-15%) if Eve tries to intercept.","title":"Protocol Summary"},{"location":"Protocols/#simulation-parameters_1","text":"Parameter Description Default Value pulse.phase Phase shift applied to each pulse (0 or \u03c0) Random pulse.mean_photon_number Average photons per pulse 0.2 pulse.duration Pulse duration 70e-12 pulse.wavelength Pulse wavelength 1550e-9 num_pulses Total number of pulses sent 1,000,000 MZI.visibility Interferometer visibility 0.98 phase_noise_std Phase noise in interferometer 0.2 SNSPD efficiency Photon detection efficiency 0.9 dark count rate Background dark count rate 10 Hz","title":"Simulation Parameters"},{"location":"Protocols/#class-alice_1","text":"class Alice(Node): def __init__(self, node_id, env, num_pulses): ...","title":"Class: Alice"},{"location":"Protocols/#class-bob_1","text":"class Bob(Node): def __init__(self, node_id, env, mzi): ...","title":"Class: Bob"},{"location":"Protocols/#coherent-one-way-cow-qkd-protocol","text":"","title":"Coherent-One-Way (COW) QKD Protocol"},{"location":"Protocols/#overview_2","text":"The COW protocol is a prepare-and-measure quantum key distribution (QKD) scheme using time-bin encoding and weak coherent pulses . It ensures security through decoy states and interference monitoring .","title":"Overview"},{"location":"Protocols/#protocol-summary_2","text":"Preparation (Alice) Sends pulses in time-bin pairs. Bit 0 : Pulse in the first bin, vacuum in the second. Bit 1 : Vacuum in the first bin, pulse in the second. Decoy state : Pulses in both bins (used for eavesdropper detection). Transmission Pulses travel through a lossy, noisy quantum channel. Measurement (Bob) 90% of pulses are measured directly to form the key (data line). 10% are routed to an interferometer (monitor line) to detect interference. Post-Processing Sifted key is extracted from correctly timed detections. Decoy statistics and interferometer clicks ( DM2 ) are used to verify security. If too many DM2 detections occur, the protocol is aborted.","title":"Protocol Summary"},{"location":"Protocols/#simulation-parameters_2","text":"Parameter Description Default num_pulses Number of time-bin pairs sent 1000 decoy_prob Probability of sending a decoy state 0.1 pulse.duration Duration of each pulse (s) 70e-12 pulse.mean_photon_number Average photon number per pulse 0.5 monitor_ratio Fraction of pulses sent to monitor line 0.1 visibility Interferometer visibility 0.98 phase_noise_std Standard deviation of phase noise 0.02 SNSPD efficiency Detector efficiency 0.9 SNSPD dark count rate Detector dark count rate (Hz) 10","title":"Simulation Parameters"},{"location":"Protocols/#classes","text":"","title":"Classes"},{"location":"Protocols/#class-alicenode","text":"def __init__(self, node_id, env, num_pulses, decoy_prob):","title":"class Alice(Node)"},{"location":"Protocols/#class-bobnode","text":"def __init__(self, node_id, env, snspd, monitor_ratio=0.1, threshold=5):","title":"class Bob(Node)"},{"location":"Protocols/#e91-quantum-key-distribution-protocol","text":"","title":"E91 Quantum Key Distribution Protocol"},{"location":"Protocols/#overview_3","text":"The E91 protocol is an entanglement-based quantum key distribution (QKD) scheme. Instead of sending quantum states directly, Alice and Bob share entangled photon pairs and perform local measurements on them. The correlation of their results provides both a shared key and a built-in security check via Bell\u2019s inequality . This simulation uses: - Entangled photon pairs (|\u03a8\u207b\u27e9 state) - Configurable depolarization, misalignment, and detector flip errors - Local projective measurements in the x\u2013z plane - A trusted entanglement manager to distribute entangled pairs","title":"Overview"},{"location":"Protocols/#protocol-summary_3","text":"Entanglement Creation A Bell pair in the state |\u03a8\u207b\u27e9 is distributed between Alice and Bob. State depolarization (Werner noise) is simulated via a tunable parameter p_depol . Measurement Alice randomly selects from measurement angles: 0, \u03c0/4, \u03c0/2 Bob randomly selects from: \u03c0/4, \u03c0/2, 3\u03c0/4 Both apply a small Gaussian misalignment to simulate real-world errors. Local projective measurements are performed using a custom function measure_local . Results are stored as \u00b11, and detector flip errors are injected with probability p_flip . Key Generation Only measurement rounds where Alice and Bob used the same nominal basis are retained. Alice and Bob convert \u00b11 \u2192 0/1. Bob flips his bit (due to anticorrelation of |\u03a8\u207b\u27e9) to match Alice. The resulting bit sequences form the sifted key . Security Check Measurement rounds with mismatched bases are used to compute the Bell parameter (S) . A violation of Bell\u2019s inequality (|S| > 2) confirms entanglement and quantum security.","title":"Protocol Summary"},{"location":"Protocols/#simulation-parameters_3","text":"Parameter Description Default Value num_pulses Number of entangled pairs generated 10,000 p_depol Depolarization probability (white noise) 0.03 misalign_deg Angle misalignment std. dev (in degrees) 1.5 p_flip Probability of bit-flip due to detector error 0.01 clock_rate Entangled pair generation rate 10 MHz","title":"Simulation Parameters"},{"location":"Protocols/#class-alice_2","text":"class Alice(Node): def __init__(self, node_id, env, num_pulses, p_depol, misalign_deg, p_flip) def run(self, manager, bob): # 1. Creates noisy entangled state # 2. Measures her half using basis angle \u03c6a # 3. Records outcome, applies noise and flip","title":"Class: Alice"},{"location":"Protocols/#class-bob_2","text":"class Bob(Node): def __init__(self, node_id, env): self.phi_list = [] self.s_list = []","title":"Class: Bob"},{"location":"Topology/","text":"Topology Module This module defines an abstract Topology class and specific subclasses for star, ring, and mesh network configurations. It is responsible for building and managing the structure of a quantum network in terms of nodes and optical channels. Classes Topology Represents a generic network topology for QKD nodes and their connecting channels. Constructor: Topology(node_specs: dict, channel_specs: dict) node_specs : A dictionary where keys are node IDs and values are dictionaries containing: type : Role of the node (e.g., \"Sender\", \"Receiver\") factory : A callable that returns a node object. channel_specs : A dictionary where keys are (node_a, node_b) tuples and values are callables that return an OpticalChannel object. Attributes: self.nodes : Dictionary mapping node IDs to constructed Node instances. self.channels : Dictionary mapping (node_a, node_b) tuples to OpticalChannel instances. Methods: buildTopology(env, num_pulses) Builds the topology by instantiating nodes and connecting them with channels. env : SimPy environment. num_pulses : Number of pulses the node will handle. get_node(node_id) Returns the node object corresponding to node_id . get_neighbors(node_id) Returns a list of node IDs that are directly connected to the specified node. StarTopology A specialization of Topology representing a star-shaped network. Constructor: StarTopology(center_node_id, leaf_node_ids, node_specs, channel_specs) center_node_id : ID of the central node. leaf_node_ids : List of IDs of peripheral nodes. Inherits and initializes from the Topology class. Attributes: self.center : Central node ID. self.leaves : List of peripheral node IDs. RingTopology A specialization of Topology representing a ring network. Constructor: RingTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the ring. Inherits from the Topology class. Attributes: self.ring_nodes : Node IDs in ring structure. MeshTopology A specialization of Topology representing a fully connected mesh network. Constructor: MeshTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the mesh. Inherits from the Topology class. Attributes: self.mesh_nodes : Node IDs in mesh structure.","title":"Topology"},{"location":"Topology/#topology-module","text":"This module defines an abstract Topology class and specific subclasses for star, ring, and mesh network configurations. It is responsible for building and managing the structure of a quantum network in terms of nodes and optical channels.","title":"Topology Module"},{"location":"Topology/#classes","text":"","title":"Classes"},{"location":"Topology/#topology","text":"Represents a generic network topology for QKD nodes and their connecting channels. Constructor: Topology(node_specs: dict, channel_specs: dict) node_specs : A dictionary where keys are node IDs and values are dictionaries containing: type : Role of the node (e.g., \"Sender\", \"Receiver\") factory : A callable that returns a node object. channel_specs : A dictionary where keys are (node_a, node_b) tuples and values are callables that return an OpticalChannel object. Attributes: self.nodes : Dictionary mapping node IDs to constructed Node instances. self.channels : Dictionary mapping (node_a, node_b) tuples to OpticalChannel instances. Methods: buildTopology(env, num_pulses) Builds the topology by instantiating nodes and connecting them with channels. env : SimPy environment. num_pulses : Number of pulses the node will handle. get_node(node_id) Returns the node object corresponding to node_id . get_neighbors(node_id) Returns a list of node IDs that are directly connected to the specified node.","title":"Topology"},{"location":"Topology/#startopology","text":"A specialization of Topology representing a star-shaped network. Constructor: StarTopology(center_node_id, leaf_node_ids, node_specs, channel_specs) center_node_id : ID of the central node. leaf_node_ids : List of IDs of peripheral nodes. Inherits and initializes from the Topology class. Attributes: self.center : Central node ID. self.leaves : List of peripheral node IDs.","title":"StarTopology"},{"location":"Topology/#ringtopology","text":"A specialization of Topology representing a ring network. Constructor: RingTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the ring. Inherits from the Topology class. Attributes: self.ring_nodes : Node IDs in ring structure.","title":"RingTopology"},{"location":"Topology/#meshtopology","text":"A specialization of Topology representing a fully connected mesh network. Constructor: MeshTopology(node_ids, node_specs, channel_specs) node_ids : List of node IDs in the mesh. Inherits from the Topology class. Attributes: self.mesh_nodes : Node IDs in mesh structure.","title":"MeshTopology"},{"location":"Usage/","text":"Usage Guide This simulator allows users to explore quantum key distribution (QKD) protocols in a configurable network environment. The system is designed to be interactive and intuitive, with visual feedback at each step. Node Selection Users can select up to 6 nodes to include in the QKD network. Each node corresponds to a city in India. Cities are displayed on an interactive map of India. Clicking on a city adds it to the network. The simulator calculates distances between selected cities to model realistic fiber-optic transmission losses. Topology Selection After selecting the nodes, users can choose a network topology to define how the nodes are connected. Available topologies include: Star A central node connected to all others. Mesh All nodes are directly connected to each other. Ring Each node is connected to two others, forming a closed loop. Each edge (i.e., connection between two nodes) can be assigned a QKD protocol to simulate. Supported protocols include: BB84 COW DPS The selected protocol will determine how key bits are generated and transmitted between nodes. Simulation and Output Once nodes, topology, and protocols are selected, the simulator runs a complete QKD session over the network. Output metrics are displayed in real time on the page, including: QBER (Quantum Bit Error Rate) Key rate Sender's last sent bits Receiver's last received bits","title":"Usage Guide"},{"location":"Usage/#usage-guide","text":"This simulator allows users to explore quantum key distribution (QKD) protocols in a configurable network environment. The system is designed to be interactive and intuitive, with visual feedback at each step.","title":"Usage Guide"},{"location":"Usage/#node-selection","text":"Users can select up to 6 nodes to include in the QKD network. Each node corresponds to a city in India. Cities are displayed on an interactive map of India. Clicking on a city adds it to the network. The simulator calculates distances between selected cities to model realistic fiber-optic transmission losses.","title":"Node Selection"},{"location":"Usage/#topology-selection","text":"After selecting the nodes, users can choose a network topology to define how the nodes are connected. Available topologies include: Star A central node connected to all others. Mesh All nodes are directly connected to each other. Ring Each node is connected to two others, forming a closed loop. Each edge (i.e., connection between two nodes) can be assigned a QKD protocol to simulate. Supported protocols include: BB84 COW DPS The selected protocol will determine how key bits are generated and transmitted between nodes.","title":"Topology Selection"},{"location":"Usage/#simulation-and-output","text":"Once nodes, topology, and protocols are selected, the simulator runs a complete QKD session over the network. Output metrics are displayed in real time on the page, including: QBER (Quantum Bit Error Rate) Key rate Sender's last sent bits Receiver's last received bits","title":"Simulation and Output"},{"location":"Utility/","text":"Utils Module This module provides utility functions and components that support key QKD operations such as entanglement generation, key rate analysis, and unit testing. 1. entanglement_manage.py Provides tools for generating Bell pairs and distributing them between two quantum nodes. Class: EntanglementManager Handles the creation and distribution of entangled quantum states between two nodes. Methods: __init__() Initializes an empty dictionary of entangled pairs. create_bell_pair(node_a: Node, node_b: Node, bell_type='00') Creates a Bell state (default \u03a6\u207a) between node_a and node_b . Applies Hadamard and CNOT to prepare the state. Returns a pair ID and the shared quantum state. Use case: Used in protocols like E91 to simulate entanglement-based QKD. 2. key_rate.py Implements formulas for computing the theoretical key generation rate. Function: binary_entropy(q) Returns the Shannon binary entropy of probability q . If q is 0 or 1, returns 0. Function: compute_key_rate(qber, sifted_rate=0.5) Computes the asymptotic key rate for a given QBER (Quantum Bit Error Rate). Applies the formula: key_rate = sifted_rate \u00d7 max(0, 1 - 2 \u00d7 H(qber)) Returns a rounded value to 6 decimal places. Use case: Estimating secret key yield under noisy channels. 3. test.py Test script to validate entanglement correlation between two nodes. Purpose: Verifies that Bell pairs created by EntanglementManager result in perfectly correlated measurement outcomes. Performs 1000 trials and prints the count of matching outcomes. Key Elements: Uses a DummyEnv class to mock SimPy environment. Creates two nodes ( Alice and Bob ). Creates Bell pairs and measures in the Z-basis. Uses Python\u2019s Counter to analyze frequency of correlated outcomes. Use case: Demonstrates entanglement fidelity and correlation statistics for Bell state \u03a6\u207a in the simulation.","title":"Utils"},{"location":"Utility/#utils-module","text":"This module provides utility functions and components that support key QKD operations such as entanglement generation, key rate analysis, and unit testing.","title":"Utils Module"},{"location":"Utility/#1-entanglement_managepy","text":"Provides tools for generating Bell pairs and distributing them between two quantum nodes.","title":"1. entanglement_manage.py"},{"location":"Utility/#class-entanglementmanager","text":"Handles the creation and distribution of entangled quantum states between two nodes. Methods: __init__() Initializes an empty dictionary of entangled pairs. create_bell_pair(node_a: Node, node_b: Node, bell_type='00') Creates a Bell state (default \u03a6\u207a) between node_a and node_b . Applies Hadamard and CNOT to prepare the state. Returns a pair ID and the shared quantum state. Use case: Used in protocols like E91 to simulate entanglement-based QKD.","title":"Class: EntanglementManager"},{"location":"Utility/#2-key_ratepy","text":"Implements formulas for computing the theoretical key generation rate.","title":"2. key_rate.py"},{"location":"Utility/#function-binary_entropyq","text":"Returns the Shannon binary entropy of probability q . If q is 0 or 1, returns 0.","title":"Function: binary_entropy(q)"},{"location":"Utility/#function-compute_key_rateqber-sifted_rate05","text":"Computes the asymptotic key rate for a given QBER (Quantum Bit Error Rate). Applies the formula: key_rate = sifted_rate \u00d7 max(0, 1 - 2 \u00d7 H(qber)) Returns a rounded value to 6 decimal places. Use case: Estimating secret key yield under noisy channels.","title":"Function: compute_key_rate(qber, sifted_rate=0.5)"},{"location":"Utility/#3-testpy","text":"Test script to validate entanglement correlation between two nodes.","title":"3. test.py"},{"location":"Utility/#purpose","text":"Verifies that Bell pairs created by EntanglementManager result in perfectly correlated measurement outcomes. Performs 1000 trials and prints the count of matching outcomes.","title":"Purpose:"},{"location":"Utility/#key-elements","text":"Uses a DummyEnv class to mock SimPy environment. Creates two nodes ( Alice and Bob ). Creates Bell pairs and measures in the Z-basis. Uses Python\u2019s Counter to analyze frequency of correlated outcomes. Use case: Demonstrates entanglement fidelity and correlation statistics for Bell state \u03a6\u207a in the simulation.","title":"Key Elements:"}]}